/**
 * Game Sharing & Records Posting
 * Handles posting game records and blog posts to Steem blockchain
 * Integrates with Keychain for user-approved transactions
 */

import { steemConfig } from "./steem.js";
import { gameRecords } from "./gamerecord.js";
import { playerRegistry } from "./playerlist.js";

export class GameShare {
  /**
   * Save game record to Steem blockchain (via steemmaze account)
   * AUTO-POST: Does NOT require Keychain permission from player.
   * Queues the record to be broadcasted by the steemmaze account.
   */
  async postGameRecord(gameData) {
    // We allow anonymous records to be queued if needed, but usually we want a username
    const player = steemConfig.username || "anonymous";

    try {
      // 1. Add game record to the central queue (steemmaze account)
      // This will be broadcasted in a batch by the internal timer or immediate trigger
      gameRecords.addGameRecordToQueue(gameData);

      // 2. Register this player as active (for leaderboard updates)
      if (steemConfig.username) {
        playerRegistry.registerActivePlayer(steemConfig.username);
        // CRITICAL UPDATE: Ensure new players are broadcast to the global registry
        // This allows other clients to 'discover' this new player automatically
        playerRegistry.addPlayerToRegistry(steemConfig.username);
      }

      // 3. Attempt broadcast immediately if conditions match (e.g. queue full or milestone)
      // We store the promise so it can be awaited if needed (e.g. for Reset Data)
      let broadcastPromise = null;

      if (steemConfig.isGameRecordsConfigured()) {
        if (gameRecords.shouldBroadcastImmediately(gameData)) {
          // Force broadcast if it's a critical Reset action (level 0)
          const isReset = gameData.level === 0;
          broadcastPromise = gameRecords.broadcastGameRecords(isReset);

          // We don't await here to keep it non-blocking by default,
          // but we attach a catch to handle background errors
          broadcastPromise.catch((err) => {
            console.debug("Background broadcast scheduled for later");
          });
        }
      }

      // Return success immediately - from the user's perspective, it's "Saved"
      return {
        success: true,
        message: "Game record saved to sync queue",
        timestamp: new Date().toISOString(),
        queued: true,
        broadcastPromise: broadcastPromise, // Return for optional awaiting
      };
    } catch (error) {
      console.error("Error saving game record:", error);
      throw error;
    }
  }

  /**
   * Post a blog post about game achievement to Steem blockchain
   * Creates a formatted blog post with game stats
   */
  async postGameBlog(gameData) {
    if (!steemConfig.username) {
      throw new Error("Not connected to Steem");
    }

    // Generate permlink from username and timestamp
    const timestamp = Date.now();
    const permlink = `steemmaze-level-${gameData.level}-${timestamp}`;

    // Generate stars display
    const starsDisplay =
      "â­".repeat(gameData.stars) + "â˜†".repeat(3 - gameData.stars);

    // Create blog post body with markdown
    const body = `
# ðŸŽ® SteemMaze Level ${gameData.level} Complete!

${starsDisplay}

---

## ðŸ“Š Game Stats

| Stat | Value |
|------|-------|
| ðŸ† Score | **${gameData.score.toLocaleString()}** |
| â±ï¸ Time | **${gameData.timeFormatted}** |
| ðŸ‘£ Steps | **${gameData.moves}** |
| ðŸ’Ž Gems | **${gameData.gems}/${gameData.totalGems}** |
| ðŸ’° Coins Earned | **${gameData.coinsEarned}** |
| ðŸ’€ Zombies Killed | **${gameData.zombiesKilled}** |
| âš¡ Max Combo | **${gameData.maxCombo}** |

---

## ðŸŽ¯ Achievement Summary

${gameData.stars === 3 ? "ðŸŒŸ **PERFECT COMPLETION!** All 3 stars earned!" : ""}
${gameData.isNewRecord ? "ðŸ… **NEW PERSONAL RECORD!**" : ""}
${gameData.zombiesKilled > 0 ? `ðŸ§Ÿ **${gameData.zombiesKilled} Zombies Purified!**` : ""}

---

**[View Full Game Record on Steem](${steemConfig.getSteemWebUrl()}/@steemmaze/steemmaze-records)**

*This post was generated by SteemMaze - The ultimate Steem-integrated maze game!*

---

Posted from [SteemMaze](https://maze.steemblocks.com)
`;

    // Create metadata
    const metadata = {
      app: "steemmaze/1.0",
      format: "markdown",
      game: {
        level: gameData.level,
        score: gameData.score,
        stars: gameData.stars,
      },
    };

    // Create blog post operation
    const commentOperation = [
      "comment",
      {
        parent_author: "",
        parent_permlink: "steemmaze",
        author: steemConfig.username,
        permlink: permlink,
        title: `SteemMaze Level ${gameData.level} - ${starsDisplay}`,
        body: body,
        json_metadata: JSON.stringify(metadata),
      },
    ];

    // Use Keychain to broadcast
    return new Promise((resolve, reject) => {
      window.steem_keychain.requestBroadcast(
        steemConfig.username,
        [commentOperation],
        "posting",
        (response) => {
          if (response.success) {
            resolve({
              success: true,
              txId: response.result?.transaction_id,
              permlink: permlink,
              url: `${steemConfig.getSteemWebUrl()}/@${steemConfig.username}/${permlink}`,
            });
          } else {
            let errorMessage = "Unknown error";
            if (typeof response.error === "string") {
              errorMessage = response.error;
            } else if (response.error?.message) {
              errorMessage = response.error.message;
            }

            reject(new Error(`Keychain error: ${errorMessage}`));
          }
        },
      );
    });
  }

  /**
   * Fetch game records from the centralized steemmaze account history.
   * Can fetch GLOBAL records (for leaderboard) or PLAYER specific records.
   */
  /**
   * Fetch game records with Smart Incremental Syncing.
   */
  async fetchGlobalGameRecords(maxRecords = 2000, filterUsername = null) {
    const targetAccount = "steemmaze";
    const BATCH_SIZE = 100; // Smaller batches for reliability
    const CACHE_KEY = "steemmaze_global_records_cache"; // LocalStorage Key

    console.log(
      `Syncing ${filterUsername ? filterUsername : "GLOBAL"} records from ${targetAccount} (Target: ${maxRecords})...`,
    );

    try {
      // 1. Load Cache
      let cachedData = {
        records: [], // The parsed, clean records
        lastSequenceId: 0, // The highest Steem Sequence ID we have processed
        timestamp: 0,
      };

      try {
        const saved = localStorage.getItem(CACHE_KEY);
        if (saved) {
          cachedData = JSON.parse(saved);
          if (!cachedData.records) cachedData.records = [];
        }
      } catch (e) {
        console.warn("Failed to load records cache, starting fresh.");
      }

      console.log(
        `Cache has ${cachedData.records.length} records. Last SeqID: ${cachedData.lastSequenceId}`,
      );

      // 2. Fetch Gap (New Records)
      let newRawHistory = [];
      let start = -1; // Start from most recent
      let reachedKnownHistory = false;
      let safetyCounter = 0;
      const MAX_BATCHES = 30; // Safety limit (approx 3000 items sync max per session)

      while (!reachedKnownHistory && safetyCounter < MAX_BATCHES) {
        safetyCounter++;

        console.debug(
          `Syncing batch ${safetyCounter}: Start ${start} (Limit ${BATCH_SIZE})...`,
        );

        const response = await fetch(steemConfig.currentNodeUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            method: "condenser_api.get_account_history",
            params: [targetAccount, start, BATCH_SIZE],
            id: 1,
          }),
        });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const result = await response.json();
        if (result.error) throw new Error(result.error.message);

        // Result is [ [id, op], [id, op] ... ] ASC order usually, or based on range
        // Condenser API for range returns them Ordered by ID (Oldest -> Newest in that range)
        // But since we page backwards, this batch is the "Newest" chunk available.
        let historyBatch = result.result || [];
        if (historyBatch.length === 0) break;

        // Process batch Newest -> Oldest to find intersection efficiently
        // historyBatch is typically [ 1000, 1001, 1002 ... 1100 ]
        // So we reverse it to traverse 1100 -> 1000
        const reversedBatch = [...historyBatch].reverse();

        for (const entry of reversedBatch) {
          const seqId = entry[0];

          // STOP CONDITION: We met a record we already have
          if (seqId <= cachedData.lastSequenceId) {
            reachedKnownHistory = true;
            break; // Stop collecting, we have the rest
          }

          // This is a NEW record
          newRawHistory.push(entry);
        }

        if (reachedKnownHistory) break;

        // Prepare next batch [Reverse Paging]
        const oldestItemInBatch = historyBatch[0]; // First item is oldest in response
        const oldestSeqId = oldestItemInBatch[0];

        if (oldestSeqId === 0) break; // Reached genesis
        start = oldestSeqId - 1;
      }

      // 3. Parse NEW records
      const parsedNewRecords = [];

      // newRawHistory is [Newest -> Oldest gap].
      for (const entry of newRawHistory) {
        const op = entry[1].op;
        if (op[0] === "custom_json" && op[1].id === "steemmaze_game_record") {
          try {
            let json = op[1].json;
            if (typeof json === "string") json = JSON.parse(json);

            if (
              json.type === "game_records_batch" &&
              Array.isArray(json.records)
            ) {
              json.records.forEach((record) => {
                parsedNewRecords.push({
                  game: {
                    level: record.level,
                    score: record.score,
                    time: record.time,
                    moves: record.moves,
                    gems_collected: record.gems_collected,
                    total_gems: record.total_gems,
                    stars: record.stars,
                    maze_size: record.maze_size,
                  },
                  stats: record.stats,
                  posted_at: record.timestamp,
                  player: record.player,
                  id: entry[0], // Sequence ID logic
                });
              });
            }
          } catch (e) {
            continue;
          }
        }
      }

      console.log(
        `Synced ${parsedNewRecords.length} NEW records from blockchain.`,
      );

      // 4. Update Cache (Merge + Sort + Trim)
      // Newest records first: [New Parsed] + [Old Cached]
      const mergedRecords = [...parsedNewRecords, ...cachedData.records];

      // Update highest sequence ID seen
      let newHighestId = cachedData.lastSequenceId;
      if (newRawHistory.length > 0) {
        // The first item in newRawHistory (which we populated Newest->Oldest) is the highest
        newHighestId = Math.max(newHighestId, newRawHistory[0][0]);
      }

      // Trim cache (keep last 5000)
      const CACHE_LIMIT = 5000;
      const finalRecords = mergedRecords.slice(0, CACHE_LIMIT);

      // Save to disk
      try {
        localStorage.setItem(
          CACHE_KEY,
          JSON.stringify({
            records: finalRecords,
            lastSequenceId: newHighestId,
            timestamp: Date.now(),
          }),
        );
      } catch (e) {
        console.warn("Storage quota exceeded, could not cache all records");
      }

      // 5. Final Filter & Return
      const resultSource = finalRecords;

      const parsedRecords = filterUsername
        ? resultSource.filter(
            (r) =>
              r.player &&
              r.player.toLowerCase() === filterUsername.toLowerCase(),
          )
        : resultSource;

      if (filterUsername && parsedRecords.length > 0) {
        playerRegistry.registerActivePlayer(filterUsername);
      }

      return parsedRecords; // Logic complete, return directly
    } catch (error) {
      console.error("Error fetching game records:", error);
      // Fallback on error: Try to return cache
      try {
        const saved = localStorage.getItem(CACHE_KEY);
        if (saved) {
          const data = JSON.parse(saved);
          return data.records || [];
        }
      } catch (e) {}
      return [];
    }
  }

  /**
   * Legacy stub - logic now handled inside main block above
   */
  async _legacy_fetch_logic_removed() {
    return [];
  }

  /**
   * Wrapper for backward compatibility and specific player fetching
   */
  async fetchPlayerGameRecords(username, maxRecords = 1000) {
    return this.fetchGlobalGameRecords(maxRecords, username);
  }

  /**
   * Get player's best achievements from blockchain
   */
  async getPlayerAchievements(username) {
    try {
      // Fetch from internal history now
      const records = await this.fetchPlayerGameRecords(username, 100);

      const achievements = {
        highest_level: 0,
        highest_score: 0,
        total_games: records.length,
        three_star_games: 0,
        total_gems_collected: 0,
        average_time: 0,
        records: records,
      };

      let totalTime = 0;

      for (const record of records) {
        if (record.game.level > achievements.highest_level) {
          achievements.highest_level = record.game.level;
        }
        if (record.game.score > achievements.highest_score) {
          achievements.highest_score = record.game.score;
        }
        if (record.game.stars === 3) {
          achievements.three_star_games++;
        }
        achievements.total_gems_collected += record.game.gems_collected || 0;
        totalTime += record.game.time || 0;
      }

      if (records.length > 0) {
        achievements.average_time = Math.round(totalTime / records.length);
      }

      return achievements;
    } catch (error) {
      console.error("Error getting player achievements:", error);
      throw error;
    }
  }
}

// Export singleton
export const gameShare = new GameShare();
